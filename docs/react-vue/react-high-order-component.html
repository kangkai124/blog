<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>当初要是看了这篇，React高阶组件早会了 | KK | FE</title>
    <meta name="description" content="Code, Guitar, Photography, and Sports">
    <link rel="icon" href="/logo_small.jpg">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.4b10c28d.css" as="style"><link rel="preload" href="/assets/js/app.78b8ba49.js" as="script"><link rel="preload" href="/assets/js/24.86ac1b5d.js" as="script"><link rel="prefetch" href="/assets/js/1.30b2587f.js"><link rel="prefetch" href="/assets/js/2.ca22baaf.js"><link rel="prefetch" href="/assets/js/3.174657bf.js"><link rel="prefetch" href="/assets/js/4.adf40659.js"><link rel="prefetch" href="/assets/js/5.df7f55d9.js"><link rel="prefetch" href="/assets/js/6.9be065d6.js"><link rel="prefetch" href="/assets/js/7.526ddef5.js"><link rel="prefetch" href="/assets/js/8.c1091489.js"><link rel="prefetch" href="/assets/js/9.19f5d287.js"><link rel="prefetch" href="/assets/js/10.62342e6f.js"><link rel="prefetch" href="/assets/js/11.34067726.js"><link rel="prefetch" href="/assets/js/12.404a2c78.js"><link rel="prefetch" href="/assets/js/13.26fcfe49.js"><link rel="prefetch" href="/assets/js/14.853db56f.js"><link rel="prefetch" href="/assets/js/15.a0676c31.js"><link rel="prefetch" href="/assets/js/16.d0a947f8.js"><link rel="prefetch" href="/assets/js/17.77d27c46.js"><link rel="prefetch" href="/assets/js/18.612d4520.js"><link rel="prefetch" href="/assets/js/19.2b375517.js"><link rel="prefetch" href="/assets/js/20.78ba3417.js"><link rel="prefetch" href="/assets/js/21.8f333a4d.js"><link rel="prefetch" href="/assets/js/22.3d596f81.js"><link rel="prefetch" href="/assets/js/23.567394cc.js"><link rel="prefetch" href="/assets/js/25.3b9c0cd6.js"><link rel="prefetch" href="/assets/js/26.033688e9.js"><link rel="prefetch" href="/assets/js/27.bdb536ec.js"><link rel="prefetch" href="/assets/js/28.9c0a483e.js"><link rel="prefetch" href="/assets/js/29.f40ca1bf.js"><link rel="prefetch" href="/assets/js/30.d13bd8a5.js"><link rel="prefetch" href="/assets/js/31.9ba48c74.js"><link rel="prefetch" href="/assets/js/32.cbe3562e.js"><link rel="prefetch" href="/assets/js/33.b92e4609.js"><link rel="prefetch" href="/assets/js/34.50e0a4d1.js"><link rel="prefetch" href="/assets/js/35.c5742db4.js"><link rel="prefetch" href="/assets/js/36.4857bad9.js"><link rel="prefetch" href="/assets/js/37.33ba67b8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4b10c28d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      KK | FE
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">笔记</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/javaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----><a href="/html-css/" class="nav-link">html/css</a></li><li class="dropdown-item"><!----><a href="/react-vue/" class="nav-link router-link-active">react/vue</a></li><li class="dropdown-item"><!----><a href="/nodeJs/" class="nav-link">nodeJs</a></li><li class="dropdown-item"><!----><a href="/build/" class="nav-link">build</a></li><li class="dropdown-item"><!----><a href="/thoughts/" class="nav-link">thoughts</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">转载</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/share/k2data/" class="nav-link">K2data</a></li><li class="dropdown-item"><!----><a href="/share/fe/" class="nav-link">博客</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">摄影</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="https://kangkai.tuchong.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  图虫
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----><a href="/photo/" class="nav-link">原创文章</a></li></ul></div></div><a href="https://github.com/kangkai124" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">笔记</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/javaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----><a href="/html-css/" class="nav-link">html/css</a></li><li class="dropdown-item"><!----><a href="/react-vue/" class="nav-link router-link-active">react/vue</a></li><li class="dropdown-item"><!----><a href="/nodeJs/" class="nav-link">nodeJs</a></li><li class="dropdown-item"><!----><a href="/build/" class="nav-link">build</a></li><li class="dropdown-item"><!----><a href="/thoughts/" class="nav-link">thoughts</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">转载</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/share/k2data/" class="nav-link">K2data</a></li><li class="dropdown-item"><!----><a href="/share/fe/" class="nav-link">博客</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">摄影</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="https://kangkai.tuchong.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  图虫
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----><a href="/photo/" class="nav-link">原创文章</a></li></ul></div></div><a href="https://github.com/kangkai124" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><div class="carbon-ads"></div><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>react/vue</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/react-vue/" class="sidebar-link">mpvue + koa 搭建小程序全栈开发环境</a></li><li><a href="/react-vue/try-mpvue.html" class="sidebar-link">mpvue 踩坑笔记</a></li><li><a href="/react-vue/read-vue.html" class="sidebar-link">Vue 源码学习</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h2 id="当初要是看了这篇，react高阶组件早会了"><a href="#当初要是看了这篇，react高阶组件早会了" aria-hidden="true" class="header-anchor">#</a> 当初要是看了这篇，React高阶组件早会了</h2><blockquote><p>作者： 大转转FE/邹存洋</p><p>mp.weixin.qq.com/s/_zQZ4Gg9WIG-3byL_p13QA</p></blockquote><h4 id="概况："><a href="#概况：" aria-hidden="true" class="header-anchor">#</a> 概况：</h4><h4 id="什么是高阶组件？"><a href="#什么是高阶组件？" aria-hidden="true" class="header-anchor">#</a> 什么是高阶组件？</h4><blockquote><p>高阶部件是一种用于复用组件逻辑的高级技术，它并不是 React API的一部分，而是从React 演化而来的一种模式。 具体地说，高阶组件就是一个接收一个组件并返回另外一个新组件的函数！</p></blockquote><p>这是官方文档说的，我没有截全，因为后面的解释会造成误解，但简单讲高阶组件（函数）就好比一个加工厂，同样的，屏幕、cpu、扬声器、电池，小米手机工厂组装完就是小米手机，魅族手机组装完就是魅族手机，基本材料都是相同的，不同工厂（高阶组件）有不同的实现及产出，当然这个工厂（高阶组件）也可能是针对某个基本材料的处理。 总之产出的结果拥有了输入组件不具备的功能，输入的组件可以是一个组件的实例，也可以是一个组件类，还可以是一个无状态组件的函数。</p><h4 id="解决什么问题？"><a href="#解决什么问题？" aria-hidden="true" class="header-anchor">#</a> 解决什么问题？</h4><p>随着项目越来越复杂，开发过程中，多个组件需要某个功能，而且这个功能和页面并没有关系，所以也不能简单的抽取成一个新的组件，但是如果让同样的逻辑在各个组件里各自实现，无疑会导致重复的代码。比如页面有三种弹窗一个有title，一个没有，一个又有右上角关闭按钮，除此之外别无它样，你总不能整好几个弹窗组件吧，这里除了tilte,关闭按钮其他的就可以做为上面说的基本材料。</p><hr><h4 id="高阶组件总共分为两大类"><a href="#高阶组件总共分为两大类" aria-hidden="true" class="header-anchor">#</a> 高阶组件总共分为两大类</h4><ul><li>代理方式</li></ul><ol><li>操纵prop</li><li>访问ref（不推荐）</li><li>抽取状态</li><li>包装组件</li></ol><ul><li>继承方式</li></ul><ol><li>操纵生命周期</li><li>操纵prop</li></ol><h4 id="代理方式之-操纵prop"><a href="#代理方式之-操纵prop" aria-hidden="true" class="header-anchor">#</a> 代理方式之 操纵prop</h4><h6 id="删除prop"><a href="#删除prop" aria-hidden="true" class="header-anchor">#</a> 删除prop</h6><div class="language- extra-class"><pre class="language-text"><code>import React from 'react'function HocRemoveProp(WrappedComponent) {  return class WrappingComPonent extends React.Component {    render() {      const { user, ...otherProps } = this.props;      return &lt;WrappedComponent {...otherProps} /&gt;    }  }}export default HocRemoveProp;
</code></pre></div><h6 id="增加prop"><a href="#增加prop" aria-hidden="true" class="header-anchor">#</a> 增加prop</h6><p>接下来我把简化了写法，把匿名函数去掉，同时换成箭头函数</p><div class="language- extra-class"><pre class="language-text"><code>import React from 'react'const HocAddProp = (WrappedComponent，uid) =&gt;  class extends React.Component {    render() {      const newProps = {        uid,      };      return &lt;WrappedComponent {...this.props}  {...newProps}  /&gt;    }  }export default HocAddProp;
</code></pre></div><p>上面HocRemoveProp高阶组件中，所做的事情和输入组件WrappedComponent功能一样，只是忽略了名为user的prop。也就是说，如果WrappedComponent能处理名为user的prop,这个高阶组件返回的组件则完全无视这个prop。</p><div class="language- extra-class"><pre class="language-text"><code>const { user, ...otherProps } = this.props;
</code></pre></div><p>这是一个利用es6语法技巧，经过上面的语句，otherProps里面就有this.props中所有的字段除了user. 假如我们现在不希望某个组件接收user的prop,那么我们就不要直接使用这个组件，而是把这个组件作为参数传递给HocRemoveProp，然后我们把这个函数的返回结果当作组件来使用 两个高阶组件的使用方法：</p><div class="language- extra-class"><pre class="language-text"><code>const  newComponent = HocRemoveProp(SampleComponent);const  newComponent = HocAddProp(SampleComponent,'1111111');
</code></pre></div><p>也可以利用decorator语法糖这样使用</p><div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from 'React';@HocRemoveProp class SampleComponent extends Component {render() {}}export default SampleComponent;
</code></pre></div><h4 id="代理方式之-抽取状态"><a href="#代理方式之-抽取状态" aria-hidden="true" class="header-anchor">#</a> 代理方式之 抽取状态</h4><p>将所有的状态的管理交给外面的容器组件，这个模式就是 抽取状态 外面的容器就是这个高阶组件</p><div class="language- extra-class"><pre class="language-text"><code>const HocContainer = (WrappedComponent) =&gt;  class extends React.Component {    constructor(props) {      super(props)      this.state = {        name: ''      }    }    onNameChange = (event) =&gt; {      this.setState({        name: event.target.value      })    }    render() {      const newProps = {        name: {          value: this.state.name,          onChange: this.onNameChange        }      }      return &lt;WrappedComponent {...this.props} {...newProps} /&gt;    }  }
@HocContainerclass SampleComponent extends React.Component {  render() {    return &lt;input name=&quot;name&quot; {...this.props.name}/&gt;  }}
</code></pre></div><p>这样当我们在使用这个已经被包裹的input组件（SampleComponent）时候 它的值就被放在了HocContainer高阶组件中，当很多这样的input组件都用这个HocContainer高阶组件时，那么它们的值都将保存在这个HocContainer高阶组件中</p><h4 id="代理方式之-包装组件"><a href="#代理方式之-包装组件" aria-hidden="true" class="header-anchor">#</a> 代理方式之 包装组件</h4><div class="language- extra-class"><pre class="language-text"><code>const HocStyleComponent = (WrappedComponent, style) =&gt;  class extends React.Component {    render() {      return (        &lt;div style={style}&gt;          &lt;WrappedComponent {...this.props} {...newProps} /&gt;        &lt;/div&gt;      )    }  }
</code></pre></div><p>这样使用</p><div class="language- extra-class"><pre class="language-text"><code>import HocStyleComponent from  './HocStyleComponent';const colorSytle ={color:'#ff5555'}const  newComponent = HocStyleComponent(SampleComponent, colorSytle);
</code></pre></div><p>-代理方式的生命周期的过程类似于堆栈调用:</p><div class="language- extra-class"><pre class="language-text"><code>didmount 一&gt; HOC didmount 一&gt;(HOCs didmount) 一&gt;(HOCs will unmount) 一&gt;HOC will unmount一&gt;unmount
</code></pre></div><h4 id="在说继承方式之前先看一个例子"><a href="#在说继承方式之前先看一个例子" aria-hidden="true" class="header-anchor">#</a> 在说继承方式之前先看一个例子</h4><div class="language- extra-class"><pre class="language-text"><code>const MyContainer = (WrappedComponent) =&gt;  class extends WrappedComponent {    render() {      return super.render();    }  }
</code></pre></div><p>这个例子很简单，相当于把WrappedComponent组件的render方法，</p><p>通过super.render()方法吐到了MyContainer 中，可以顺序调用。</p><p>继承方式的生命周期的过程类似队列调用:</p><div class="language- extra-class"><pre class="language-text"><code>didmount 一&gt; HOC didmount 一&gt;(HOCs didmount) 一&gt;will unmount一&gt;HOC will unmount一&gt; (HOCs will unmount)
</code></pre></div><ol><li>代理方式下WrappedComponent会经历一个完整的生命周期，产生的新组件和参数组件是两个不同的组件，一次渲染，两个组件都会经历各自的生命周期</li><li>而在继承方式下，产生的新组件和参数组件合二为一，super.render只是生命周期中的函数，变成一个生命周期。</li></ol><p>来看下面的例子你就会明白了。</p><h4 id="继承方式之-操纵生命周期-渲染劫持"><a href="#继承方式之-操纵生命周期-渲染劫持" aria-hidden="true" class="header-anchor">#</a> 继承方式之 操纵生命周期(渲染劫持)</h4><p>首先创建一个高阶，在创建一个使用高阶组件的组件，也就是是输入组件，最后我在改变这个输入组件props</p><div class="language- extra-class"><pre class="language-text"><code>import * as React from 'react';const HocComponent = (WrappedComponent) =&gt;  class MyContainer extends WrappedComponent {    render() {      if (this.props.time &amp;&amp; this.state.success) {        return super.render()      }      return &lt;div&gt;倒计时完成了...&lt;/div&gt;    }  }
</code></pre></div><p>这个高阶组件会直接读取输入组件中的props,state,然后控制了输入组件的render展示 只有在props.time和state.success同时为真的时候才会展示</p><div class="language- extra-class"><pre class="language-text"><code>import * as React from 'react';import HocComponent from './HocComponent'@HocComponentclass DemoComponent extends React.Component {  constructor(props) {    super(props);   this.state = {    success: true,   }; }  render() {    return   &lt;div&gt;我是一个组件&lt;/div&gt;  }} export default DemoComponent;
</code></pre></div><p>然后调用，递减time数值直到变为0最后页面的效果就是，当然他不是循环的。先展示”我是一个组件“，我设置了两秒，之后展示”倒计时完成“</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/T81bAV0NNNibuOtNsFhnTeL7UiaaLS75W9x3Hv2Stb43iap58TJa2PAB4dTqYYTYvchqrhgfXtavHAibK6KvFIyHVA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p><p>由此可以看出高阶组件也可以控制state</p><p>但是最好要限制这样做，可能会让WrappedComponent组件内部状态变得一团糟。建议可以通过重新命名state，以防止混淆。</p><h4 id="继承方式之-操纵prop"><a href="#继承方式之-操纵prop" aria-hidden="true" class="header-anchor">#</a> 继承方式之 操纵prop</h4><div class="language- extra-class"><pre class="language-text"><code>const HOCPropsComponent = (WrappedComponent) =&gt;  class extends WrappedComponent {    render() {      const elementsTree = super.render();      let newProps = {        color: (elementsTree &amp;&amp; elementsTree.type === 'div') ? '#fff' : '#ff5555'      };      const props = Object.assign({}, elementsTree.props, newProps)      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)      return newElementsTree    }  }
</code></pre></div><p>这样就传入了新的props</p><div class="language- extra-class"><pre class="language-text"><code>React.cloneElement( element, [props], [...children])参数：TYPE（ReactElement），[PROPS（object）]，[CHILDREN（ReactElement）
</code></pre></div><p>克隆并返回一个新的 ReactElement ，新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props。</p><h5 id="还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，"><a href="#还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，" aria-hidden="true" class="header-anchor">#</a> 还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，</h5><div class="language- extra-class"><pre class="language-text"><code>class addProps extends React.Component {  render() {    const newProps = 'uid'    return this.props.children(newProps)  }} 
</code></pre></div><p>使用方式</p><div class="language- extra-class"><pre class="language-text"><code>&lt;addProps&gt;{   (argument) =&gt; &lt;div&gt;{argument}&lt;/div&gt;}&lt;/addProps&gt;
</code></pre></div><p>感觉很方便，但是每次渲染都会重新定义一个新的函数，如果不想的话就不要定义匿名函数，</p><div class="language- extra-class"><pre class="language-text"><code>showUid(argument) {    return &lt;div&gt;{argument}&lt;/div&gt;}
</code></pre></div><h5 id="彩蛋recompose库"><a href="#彩蛋recompose库" aria-hidden="true" class="header-anchor">#</a> 彩蛋recompose库</h5><p>recompose是一个很流行的库，它提供了很多很有用的高阶组件（小工具），而且也可以优雅的组合它们。</p><h6 id="step-1-扁平props"><a href="#step-1-扁平props" aria-hidden="true" class="header-anchor">#</a> Step 1 扁平props.</h6><p>我们有这样一个组件</p><div class="language- extra-class"><pre class="language-text"><code>const Profile = ({ user }) =&gt; ( &lt;div&gt;     &lt;div&gt;Username: {user.username}&lt;/div&gt;      &lt;div&gt;Age: {user.age}&lt;/div&gt; &lt;/div&gt; )
</code></pre></div><p>如果想要改变组件接口来接收单个 prop 而不是整个用户对象，可以用 recompose 提供的高 阶组件 flattenProp 来实现。</p><div class="language- extra-class"><pre class="language-text"><code>const Profile = ({ username，age }) =&gt; ( &lt;div&gt;     &lt;div&gt;Username: {username}&lt;/div&gt;      &lt;div&gt;Age: {age}&lt;/div&gt; &lt;/div&gt; )
</code></pre></div><p>const ProfileWithFlattenUser = flattenProp('user')(Profile)； 现在我们希望同时使用多个高阶组件：一个用于扁平化处理用户 prop，另一个用于重命名用 户对象的单个 prop。 此时 recompose 库提供的 compose 函数就派上用场了。</p><div class="language- extra-class"><pre class="language-text"><code>const enhance = compose( flattenProp('user'), renameProp('username', 'name') )
</code></pre></div><p>然后按照以下方式将它应用于原有组件：</p><div class="language- extra-class"><pre class="language-text"><code> const EnhancedProfile = enhance(Profile)
</code></pre></div><p>还可以将 compose 函数用 在我们自己的高阶组件上，甚至结合使用都可以：</p><div class="language- extra-class"><pre class="language-text"><code>const enhance = compose(  flattenProp('user'),  renameProp('username', 'name'),  withInnerWidth )
</code></pre></div><h6 id="step-2-提取输入表单的state"><a href="#step-2-提取输入表单的state" aria-hidden="true" class="header-anchor">#</a> Step 2 提取输入表单的State</h6><p>我们将从Recompose库中使用withStateHandlers高阶组件。 它将允许我们将组件状态与组件本身隔离开来。 我们将使用它为电子邮件，密码和确认密码字段添加表单状态，以及上述字段的事件处理程序。</p><div class="language- extra-class"><pre class="language-text"><code>import { withStateHandlers, compose } from &quot;recompose&quot;;const initialState = {  email: { value: &quot;&quot; },  password: { value: &quot;&quot; },  confirmPassword: { value: &quot;&quot; }};const onChangeEmail = props =&gt; event =&gt; ({  email: {    value: event.target.value,    isDirty: true  }});const onChangePassword = props =&gt; event =&gt; ({  password: {    value: event.target.value,    isDirty: true  }});const onChangeConfirmPassword = props =&gt; event =&gt; ({  confirmPassword: {    value: event.target.value,    isDirty: true  }});const withTextFieldState = withStateHandlers(initialState, {  onChangeEmail,  onChangePassword,  onChangeConfirmPassword});export default withTextFieldState;
</code></pre></div><p>withStateHandlers它接受初始状态和包含状态处理程序的对象。调用时，每个状态处理程序将返回新的状态。</p><p>好了，很辛苦也很感谢你能看到这里，关于recompose介绍就到这里了，喜欢的朋友可以深入研究recompose其它的方法和源码。</p><p>不准确的地方欢迎拍砖</p></div><!----><div class="bsa-cpc-wrapper"><div class="bsa-cpc"></div></div></div></div></div>
    <script src="/assets/js/24.86ac1b5d.js" defer></script><script src="/assets/js/app.78b8ba49.js" defer></script>
  </body>
</html>
