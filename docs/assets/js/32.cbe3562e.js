(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{178:function(t,e,s){"use strict";s.r(e);var r=s(0),i=Object(r.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._m(1),t._m(2),t._m(3),t._m(4),t._m(5),s("p",[t._v("用 nginx 镜像启动一个容器，命名为 webserver ，并且映射了80端口，这样我们可以用在浏览器中输入 http://localhost:3000 去访问这个 nginx 服务器。")]),t._m(6),s("p",[t._v("以交互式终端方式进入 webserver 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。")]),t._m(7),t._m(8),t._m(9),t._m(10),t._m(11),t._m(12),t._m(13),t._m(14),t._m(15),t._m(16),s("p",[t._v("因此， 这类指令中的源文件的路径都是相对路径。")]),t._m(17),t._m(18),t._m(19),t._m(20),t._m(21),s("p",[t._v("FROM 指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。")]),t._m(22),t._m(23),t._m(24),t._m(25),t._m(26),t._m(27),s("p",[s("code",[t._v("<源路径>")]),t._v(" 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 "),s("a",{attrs:{href:"https://golang.org/pkg/path/filepath/#Match",target:"_blank",rel:"noopener noreferrer"}},[t._v("filepath.Match"),s("OutboundLink")],1),t._v(" 规则。")]),t._m(28),t._m(29),t._m(30),t._m(31),t._m(32),t._m(33),t._m(34),t._m(35),t._m(36),s("p",[t._v("在实际执行中，会将其变更为:")]),t._m(37),s("p",[t._v("这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解 析处理。")]),t._m(38),t._m(39),s("p",[t._v("下面是个使用 ENTRYPOINT 的例子：")]),t._m(40),t._m(41),t._m(42),s("p",[t._v("该脚本的内容就是根据 CMD 的内容来判断，如果是 的话，则切换到 redis 用户身份启动服务器，否则依旧使用身份执行。比如:")]),t._m(43),t._m(44),t._m(45),t._m(46),t._m(47),t._m(48),t._m(49),t._m(50),s("p",[t._v("...")]),t._m(51),t._m(52),t._m(53),t._m(54),t._m(55),t._m(56),t._m(57),t._m(58),s("p",[t._v("上面命令查看指定容器的信息。")]),t._m(59),t._m(60),s("p",[t._v("可以看到，访问本机的 49155 端口就可以访问容器内 web 应用提供的界面。")]),t._m(61),t._m(62),t._m(63),s("p",[t._v("支持的格式：")]),t._m(64),t._m(65),t._m(66)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"学习-docker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#学习-docker","aria-hidden":"true"}},[this._v("#")]),this._v(" 学习 docker")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker images")]),this._v("\t\t\t\t\t\t\t列出已经下载下来的镜像")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker images ubuntu")]),this._v(" \t\t\t\t\t列出特定的某个镜像")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker images -f since=mongo:3.2")]),this._v("\t\tmongo:3.2 之后建立的镜像")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("run = create 容器 + start 容器")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("docker run --name webserver -d -p 3000:80 nginx\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("docker exec -it webserver bash\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("# docker build [选项] <上下文路径/URL/->\ndocker build -t nginx:v3 .\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果注意，会看到 docker build 命令最后有一个"),e("code",[this._v(".")]),this._v(" 。"),e("code",[this._v(".")]),this._v(" 这是在指定上下文路径。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"镜像构建上下文（context）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#镜像构建上下文（context）","aria-hidden":"true"}},[this._v("#")]),e("em",[this._v("镜像构建上下文（Context）")]),this._v(" *")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker build")]),this._v(" 的工作原理："),e("em",[this._v("Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。 docker 命令这样的客户端工具与 Docker 引擎交互，完成各种功能。虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，"),e("strong",[this._v("一切都是使用的远程调用形式在服务端（Docker 引擎）完成")]),this._v("。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当我们进行镜像构建的时候，并非所有定制都会通过指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、指令等。"),e("strong",[this._v("而 "),e("code",[this._v("docker build")]),this._v(" 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径， **"),e("code",[this._v("docker build")]),this._v(" 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。**这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果在 "),e("code",[this._v("Dockerfile")]),this._v(" 中这么写：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v(" COPY ./package.json /app/\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("这并不是要复制 "),s("code",[t._v("docker build")]),t._v(" 命令所在的目录下的 "),s("code",[t._v("package.json")]),t._v(" ，也不是复制 "),s("code",[t._v("Dockerfile")]),t._v(" 所在目录下的 "),s("code",[t._v("package.json")]),t._v(" ，而是复制 "),s("strong",[t._v("上下文（即下面shell中的 "),s("code",[t._v(".")]),t._v("）")]),t._v(" 目录下的 "),s("code",[t._v("package.json")]),t._v(" 。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("# docker build [选项] <上下文路径/URL/->\ndocker build -t nginx:v3 .\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker build -t nginx:v3")]),this._v(" 中的这个 "),e("code",[this._v(".")]),this._v(" ，实际上是在指定上下文的目录，"),e("code",[this._v("docker build")]),this._v(" 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果观察 "),e("code",[this._v("docker build")]),this._v(" 输出，我们其实已经看到了这个发送上下文的过程：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("$ docker build -t nginx:v3 .\nSending build context to Docker daemon 2.048 kB\n...\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 "),e("code",[this._v(".gitignore")]),this._v(" 一样的语法写一个 "),e("code",[this._v(".dockerignore")]),this._v(" ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"使用-dockerfile-定制镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-dockerfile-定制镜像","aria-hidden":"true"}},[this._v("#")]),this._v(" 使用 Dockerfile 定制镜像")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("RUN")]),this._v(" 执行命令，其格式有两种：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("shell 格式：RUN <命令>")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index\n.html\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v('exec 格式： RUN ["可执行文件", "参数1", "参数2"]')])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("COPY")]),this._v(" 复制文件：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("<目标路径>")]),this._v(" 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 "),e("code",[this._v("WORKDIR")]),this._v(" 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("**使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。**这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("ADD")]),this._v(" 更高级的复制文件：")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("比如 "),s("code",[t._v("<源路径>")]),t._v(" 可以是一个 URL，也可以是一个 "),s("code",[t._v("tar")]),t._v(" 压缩文件，"),s("code",[t._v("ADD")]),t._v(" 会自动解压缩这个文件到 "),s("code",[t._v("<目标路径>")]),t._v(" 去。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("尽可能的使用 COPY ，仅在需要自动解压缩的场合使用 ADD。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CMD")]),this._v(" 容器启动命令")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在指令格式上，一般推荐使用 "),e("code",[this._v("exec")]),this._v(" 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 ，而不要使用单引号。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果使用 shell 格式的话，实际的命令会被包装为 "),e("code",[this._v("sh -c")]),this._v(" 的参数的形式进行执行。比如:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("CMD echo $\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('CMD [ "sh", "-c", "echo $HOME" ]\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("ENTRYPOINT")]),this._v(" 入口点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("ENTRYPOINT 和 CMD 一样，都是指定容器启动程序及参数。不同的是，ENTRYPOINT 可以在使用 docker 命令时，"),e("strong",[this._v("在后面加参数。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('FROM alpine:3.4\n...\nRUN addgroup -S redis && adduser -S -G redis redis\n...\nENTRYPOINT ["docker-entrypoint.sh"]\nEXPOSE 6379\nCMD [ "redis-server" ]\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 "),e("code",[this._v("docker-entrypoint.sh")]),this._v(" 脚本。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('#!/bin/sh\n...\n# allow the container to be started with `--user`\nif [ "$1" = \'redis-server\' -a "$(id -u)" = \'0\' ]; then\n    chown -R redis .\n    exec su-exec redis "$0" "$@"\nfi\nexec "$@"\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("$ docker run -it redis id\nuid=0(root) gid=0(root) groups=0(root)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("ENV")]),this._v(" 设置环境变量")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("ARG")]),this._v(" 构建参数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("VOLUME")]),this._v(" 定义匿名卷")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("EXPOSE")]),this._v(" 声明端口")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("WORKDIR")]),this._v(" 指定工作目录")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("USER")]),this._v(" 指定当前用户")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("HEALTHCHECK")]),this._v(" 健康检查")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker rmi")]),this._v(" \t\t\t删除本地镜像")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker rm")]),this._v("\t\t\t删除")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker run")]),this._v(" \t\t新建并启动  (-itd)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在用 "),e("code",[this._v("docker run")]),this._v(" 命令的时候，使用 "),e("code",[this._v("-v")]),this._v(" 标记来创建一个数据卷并挂载到容器里。在一次 "),e("code",[this._v("run")]),this._v(" 中多次使用可以挂载多个数据卷。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("$ sudo docker run -d -P --name web -v /webapp training/webapp py\nthon app.py\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("上面创建了一个名为 web 的容器，并加载一个数据卷到容器的 "),e("code",[this._v("/webapp")]),this._v(" 目录。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("删除容器不会自动删除数据卷，使用 "),e("code",[this._v("docker rm -v")]),this._v(" 命令同时删除数据卷。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("$ docker inspect web\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("使用 "),e("code",[this._v("-P")]),this._v(" 或者 "),e("code",[this._v("-p")]),this._v(" 指定端口映射")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("# -P (大写) 随机映射一个 49000~49900 的端口到内部容器开放的网络端口\n$ sudo docker run -d -P training/webapp python app.py\n$ sudo docker ps -l\nCONTAINER ID  IMAGE                   COMMAND       CREATED\n   STATUS        PORTS                    NAMES\nbc533791f3f5  training/webapp:latest  python app.py 5 seconds ag\no  Up 2 seconds  0.0.0.0:49155->5000/tcp  nostalgic_morse\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("可以通过 "),e("code",[this._v("docker logs")]),this._v(" 命令来查看应用的信息。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('$ sudo docker logs -f nostalgic_morse\n* Running on http://0.0.0.0:5000/\n10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -\n10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1"\n404 -\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("-p")]),this._v(" (小写)则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("ip:hostPort:containerPort")]),e("li",[this._v("ip::containerPort")]),e("li",[this._v("hostPort:containerPort")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("$ sudo docker run -d -p 5000:5000 training/webapp python app.py\n$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py\n$ sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("docker port nostalgic_morse 5000")]),this._v(" 查看当前映射的端口配置")])}],!1,null,null,null);e.default=i.exports}}]);