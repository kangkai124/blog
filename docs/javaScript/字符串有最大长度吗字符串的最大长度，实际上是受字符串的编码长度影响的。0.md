1. 字符串有最大长度吗?

   字符串的最大长度，实际上是受字符串的编码长度影响的。

2. 0.1 + 0.2 为什么不等于 0.3 ？

   JavaScript 中的 Number ，它的实现遵循 [IEEE 754](http://grouper.ieee.org/groups/754/) 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。

   详细内容在[JavaScript 的精确计算](<https://github.com/kangkai124/blog/issues/13>)

3. ES6 新加入的 Symbol 是个什么东西？

   ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。

4. 为什么给对象添加的方法能用在基本类型上？

   `.` 运算符提供了**装箱**操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

#### 装箱转换

每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。

强制 Symbol 装箱：

```js
    var normal = Symbol("aa");
		var symbolObject = (function(){ return this; }).call(Symbol("a"));

    console.log(typeof normal); //symbol
    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true

		// 当然，可以显式的调用装箱能力
		var symbolObject2 = Object(Symbol('a'))

```

**Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。**

#### 拆箱转换

即对象类型到基本类型的转换。

对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。

拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。

到 Number 的拆箱，会先调用 valueOf 再调用 toString，到 String 的拆箱，则相反。



ES6 允许对象显式指定 Sumbol.toPrimitive 覆盖原有行为：

```js
    var o = {
        valueOf : () => {console.log("valueOf"); return {}},
        toString : () => {console.log("toString"); return {}}
    }

    o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}


    console.log(o + "")
    // toPrimitive
    // hello

```

